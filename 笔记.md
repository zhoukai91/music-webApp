## 1、在webpack中配置别名
    webpack.base.conf.js
        alias: {
              '@': resolve('src'),
              'common': resolve('src/common')
            }
*************
在.vue文件的style标签内引入的stylus文件内，不可以再次引入其它stylus文件，否则会保存。

    原因(个人观点):webpack在解析vue文件是，vue-loader无法解析二重styus引用;

在样式文件中，波浪号，@import "~common/stylus/reset.styl";
    这个应该是webpack的路径解析相关的用法。
    ~这里应该是指定的模块解析目录下进行匹配对应文件

  tag指定生成的标签： router-link的 tag="div"

URL拼接参数的时候，使用encodeURIComponet进行转义

使用keep-alive,用来缓存组件,避免多次加载相应的组件,减少性能消耗

    注意：因为keep-alive会将组件保存在内存中，并不会销毁以及重新创建，所以不会重新调用组件的created等方法，需要用activated与deactivated这两个生命钩子来得知当前组件是否处于活动状态

浏览器的刷新通常时17ms，setTimeout(fn,20)包裹DOM初始化操作,
和Vue.nextTick()功能类似

#### this的指向问题：
“超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined

ES6箭头函数内，this指向函数的运行环境

忽视ESlist检测

    加注释：eslint-disable

### 依赖
* 1、baler-runtime：对ES6语法做转义
* 2、fastclick:解决移动端300ms延时问题,用法：fastclick.attach(document.body)
* 3、babel-ployfill:ES6 API补丁

### betterScroll插件使用：

无限循环滚动，开启snap.loop时，betterScroll插件会拷贝前后2个元素。

    因此滚动元素的宽度应该 + 2 * sliderWidth
    同时，当前的显示页的index = this.slider.getCurrentPage().pageX

***********
# 技巧
1、 当抓取网站数据被限制了host和refer时，通过后台代理手段，设置转发请求的host和refer，达到抓取网上数据

2、 通过对外层元素设置padding值，在页面预留正方形位置

    .img-wrapper{
      position: raletive;
      width:100; hieght:0;
      padding-top:100% //技巧，当没有设置高度时，padding值相对与宽度进行计算
    }
    .content{ position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      hieght: 100%;
    }


#### flex布局：
* flex-direction: column； 决定主轴的方向，元素垂直方向排列，
* justify-content: center； 项目在主轴上的对齐方式
* align-item:center； 元素垂直居中(左右排列时，项目在交叉轴上居中)，

## JSONP源码解析

  opts.param = 'callbackName' + enc(id) ,设置回调函数名 ,callbackName 默认为callback

  给window对象挂载全局函数，当JSONP请求成功时，调用该函数：

    window[id] = function(data){
        if (fn) fn(null, data);
      };

4-7 ing

